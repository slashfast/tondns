directive @cacheControl(maxAge: Int, scope: CacheControlScope, inheritMaxAge: Boolean) on FIELD_DEFINITION | OBJECT | INTERFACE | UNION

input AnalyticsUtmTags {
  source: String
  medium: String
  campaign: String
  term: String
  content: String
}

input NftClickPromoEvent {
  source: String!
  nftAddress: String!
  pageType: String!
  pageId: String
  pageTitle: String!
  pageHash: String
  url: String!
  clientTimestampMs: Float!
}

input PageViewEvent {
  firstInTab: Boolean!
  firstInSession: Boolean!
  clientTimestampMs: Float!
  pageType: String!
  pageId: String
  pageTitle: String!
  pageHash: String
  url: String!
}

input BuyNftEvent {
  firstInTab: Boolean!
  firstInSession: Boolean!
  clientTimestampMs: Float!
  nftAddress: String!
  saleAddress: String!
}

input TxReadyEvent {
  clientTimestampMs: Float!
  tx: CheckTxPayload!
}

input FragmentClickEvent {
  nftAddress: String!
  pageType: String!
  pageId: String
  pageTitle: String!
  pageHash: String
  url: String!
  clientTimestampMs: Float!
}

input NftActionButtonClickEvent {
  nftAddress: String!
  buttonType: String!
  buttonTitle: String
  buttonUrl: String
  pageType: String!
  pageId: String
  pageTitle: String!
  pageHash: String
  url: String!
  clientTimestampMs: Float!
}

input PromotionBannerClick {
  bannerName: String!
  pageType: String!
  pageId: String
  pageTitle: String!
  pageHash: String
  url: String!
  clientTimestampMs: Float!
}

input CustomNoSchemeEvent {
  name: String!
  payload: String
  pageType: String!
  pageId: String
  pageTitle: String!
  pageHash: String
  url: String!
  clientTimestampMs: Float!
}

input EventsPayload {
  clientId: String!
  tabId: String!
  sessionId: String!
  utm: AnalyticsUtmTags!
  referer: String
  nftClickPromo: [NftClickPromoEvent!]
  pageView: [PageViewEvent!]
  buy: [BuyNftEvent!]
  acceptOffer: [BuyNftEvent!]
  txReady: [TxReadyEvent!]
  nftActionButtonClick: [NftActionButtonClickEvent!]
  telemintBuyClick: [FragmentClickEvent!]
  telemintBidClick: [FragmentClickEvent!]
  promotionBannerClick: [PromotionBannerClick!]
  noScheme: [CustomNoSchemeEvent!]
}

type Mutation {
  saveEvents(events: EventsPayload!): Boolean
  createLoginMessage: String!
  login(credentials: LoginCredentialsInput!): Login!
  logout(reason: String): Boolean!
  updateMe(data: UserInput!): User!
  deleteCover: User!
  authLinkTelegram(jsonAuthData: String!): Boolean!
  authUnlinkTelegram: Boolean!
  authUpdateLang(lang: UserLang!): Boolean!
  loginTonConnect(payload: TonConnectAuthPayload!): Login!
  authTonConnectSetStorage(storageJSON: String!, storageVersion: Float!): Boolean!
  adminSetUserBannedFlag(address: String!, banned: Boolean!, comment: String!): Boolean!
  absurdDropStart(userAddress: String!): TonTx!
  dogSexStartMerge(leftNftAddress: String!, rightNftAddress: String): DogSexStartResult!
  dogSexAcceptMerge(mergeId: ID!, rightNftAddress: String!, withChild: Boolean!): DogSexAcceptResult!
  makeMove(nftAddress: String!, move: GameMove!, lang: UserLang): MoveResponse!
  walletEggLinkTonWallet(tonConnectProof: TonConnectAuthPayload!): WalletEggStatus!
  walletEggGenerateWallet: WalletEggStatus!
  walletEggLogout: WalletEggStatus!
  walletEggMakeMove(gameId: ID!, nftAddress: String!, move: GameMove!): WalletEggGame!
  walletEggDebugNewBot: String!
  walletEggDebugMoveBot(id: String!): String!
  walletEggDebugAddNftBot(id: String!): String!
  walletEggDebugDeleteUser(idOrWallet: String!): String!
  walletEggUpdateTelegramVisibility(show: Boolean!): Boolean!
  walletEggSaveEvent(data: WalletEggSaleEvent!): Boolean!
  walletEggMakeSale(nftAddress: String!, price: Float!): WalletEgg!
  walletEggCancelSale(nftAddress: String!): WalletEgg!
  walletEggCheckTask(code: WETaskCode!): WETaskResult!
  createMyGemsWallet: GemsWalletAuth!
  gemsWalletStartConnect(universalUrl: String!): GemsWalletConnectResult!
  gemsWalletResolveConnect(connectPayload: String!, wallet: String!, accept: Boolean!): Boolean!
  gemsWalletMintAvatar(image: GemsWalletImage!): GemsWalletAvatarResponse!
  gemsWalletDestroy: Boolean!
  gemsWalletDisconnectDapp(dappId: ID!): Boolean!
  gemsWalletResolveRequest(requestId: ID!, accept: Boolean!): Boolean!
  gemsWalletSubscribeAvatarNotify: Boolean!
  mintGetGemsDns(domain: String!, bidNano: String!): TonTx!
  launchpadCreateBill(launchpadItemId: String!, count: Int): LaunchpadBill!
  saveLaunchpadStartNotificationSubscription(launchpadItemId: String!, isSubscribing: Boolean!): SaveLaunchpadStartNotificationSubscriptionStatus!
  lostDogsWayLinkTonWallet(tonConnectProof: TonConnectAuthPayload!): LostDogsWayUserProfileResponse!
  lostDogsWayGenerateWallet: LostDogsWayUserProfileResponse!
  lostDogsWayRemoveWallet: LostDogsWayUserProfileResponse!
  lostDogsWayVote(value: String!): LostDogsWayCurrentRoundVote!
  lostDogsWayViewPrevRound: Boolean!
  lostDogsWayCompleteTask(type: LostDogsWayUserTaskType!): LostDogsWayCompleteTasksResponse!
  lostDogsWayCompleteCommonTask(id: ID!): LostDogsWayCompleteCommonTasksResponse!
  lostDogsWayBuyDogsNotcoin(dogsCount: Int!): TonTx!
  lostDogsWayBuyDogsStar(dogsCount: Int!): StarsTx!
  lostDogsWayBuyBoost(type: LostDogsWayBoostType!): StarsTx!
  lostDogsWayCheckTgPayment(check: String!): Boolean!
  lostDogsWayClaimNotcoins: TonTx!
  lostDogsWaySaveEvent(data: LostDogsWaySaveEventPayload!): Boolean!
  lostDogsWayApplyNotEmptyWallet(taskId: ID!): LostDogsWayApplyNotEmptyWalletResponse!
  lostDogsWayApplyAdsGram(taskId: ID!): LostDogsWayCompleteAdsGramTasksResponse!
  lostDogsWaySaveExchangeForm(data: LostDogsWaySaveExchangeFormPayload!): LostDogsWaySaveExchangeFormResponse!
  lostDogsWayClaimWoof: TonTx!
  lostDogsWayMovieVote(value: String!): LostDogsWayMovieCurrentRoundVote!
  lostDogsWayMovieVoteDate(value: String!, dayId: String!): LostDogsWayMovieCurrentRoundVote!
  lostDogsWayMovieViewPrevRound: Boolean!
  lostDogsWayMovieCompleteCommonTask(id: ID!): LostDogsWayCompleteCommonTasksResponse!
  lostDogsWayMovieBuyNotcoin(amount: String!): TonTx!
  lostDogsWayMovieBuyNotcoinVariant(amount: String!, variant: String!): TonTx!
  lostDogsWayMovieBuyBoost(type: LostDogsWayMovieBoostType!): StarsTx!
  lostDogsWayMovieCompleteTask(type: LostDogsWayUserTaskType!): LostDogsWayCompleteTasksResponse!
  lostDogsWayMovieSaveEvent(data: LostDogsWayMovieSaveEventPayload!): Boolean!
  syncItem(itemAddress: String!): NftItem @deprecated(reason: "use nftItemSync/nftCollectionSync")
  nftRefreshMetadata(address: String!): NftItem @deprecated(reason: "use nftItemSync")
  syncNft(address: String!): SyncNftStatus!
  syncCollection(address: String!): SyncCollectionStatus!
  superApproveCollection(address: String!, isApproving: Boolean!, comment: String): Boolean
  superApproveNft(address: String!, isApproving: Boolean!, comment: String): Boolean!
  superSetPriorityNft(address: String!, priority: Int!, comment: String): Boolean!
  superSetPriorityCollection(address: String!, priority: Int!, comment: String): Boolean!
  superBlockNft(address: String!, isBlocking: Boolean!, comment: String): Boolean!
  superBlockCollection(address: String!, isBlocking: Boolean!, comment: String): Boolean!
  superVerifyCollection(address: String!, isVerifying: Boolean!, comment: String): Boolean!
  superAgeRestrictCollection(address: String!, isAgeRestrict: Boolean!, comment: String): Boolean!
  collectionRefreshMetadata(address: String!): NftCollection
  createColorCookie(nftAddress: String!): String!
  nftReveal(nftAddress: String!): Boolean!
  nftUpdateCollection(payload: UpdateCollectionInput!): UpdateCollectionResult!
  nftCreateTransferPayload(nftAddress: String!, newOwnerAddress: String!): TonTx!
  superGoogleDeploy(docUrl: String!, network: String!): Boolean!
  nftLinkAddress(nftAddress: String!, newAddress: String): TonTx!
  nftSetHiddenFlag(nftAddress: String!, isHiddenByUser: Boolean!): Boolean!
  nftClaim(nftAddress: String!): TonTx!
  debugMintRandomCollection: String!
  debugForceReindexCollection(address: String!): Boolean!
  debugMintRandomNftInCollection(collectionAddress: String!, index: Int!): Boolean!
  debugMintRandomSingleNft: String!
  debugAddCollectionToIndexer(address: String!): Boolean!
  draftNftSingle(data: NftSingleInput!): CreateNftDraftResult!
  draftNftItem(data: NftItemInput!): CreateNftDraftResult!
  confirmDraftItem(draftId: ID!): NftItem!
  draftCollection(data: NftCollectionInput!): CreateCollectionDraftResult!
  confirmDraftCollection(draftId: ID!): NftCollection!
  nftAuctionCreate(params: NftAuctionParams!): NftActionResult! @deprecated(reason: "use nftAuctionNoCancelCreate")
  nftAuctionNoCancelCreate(params: NftAuctionNoCancelParams!): NftActionResult!
  nftAuctionActivate(auctionAddress: String!): String! @deprecated(reason: "use nftAuctionNoCancelCreate")
  nftAuctionCancelMessage(auctionAddress: String!): NftActionMessage!
  nftAuctionStopMessage(auctionAddress: String!): NftActionMessage!
  nftAuctionFinishMessage(auctionAddress: String!): NftActionMessage!
  nftOfferCreate(params: NftOfferParams!, version: String): TonTx!
  nftOfferCancel(offerAddress: String!): TonTx!
  nftOfferAccept(offerAddress: String!): TonTx!
  nftOfferRejectByNftOwner(offerAddress: String!, reason: String): Boolean!
  nftFixPriceSaleCreate(nftAddress: String!, fullPrice: String!, currency: Currency, omitRoyalty: Boolean): TonTx!
  nftFixPriceSaleCancel(nftAddress: String!): TonTx!
  nftFixPriceSaleChangePrice(nftAddress: String!, fullPrice: String!, currency: Currency): TonTx!
  attributesCheck(nftAddress: String!): AttributesCheckResponse!
  nftFixPriceSaleBuy(nftAddress: String!, version: String): TonTx!
  nftAuctionBidCreate(saleAddress: String!, amount: String!, version: String): TonTx!
  nftTelemintBidCreate(nftAddress: String!, amount: String!, version: String): TonTx!
  calculateCart(cart: [CartCalculationItemInput!]!): [CartCalculationItemPayload!]!
  saveCollectionNotifications(collectionAddress: String!, settings: CollectionNotificationSettingsInput!): CollectionNotificationSettings!
  saveNftNotifications(nftAddress: String!, settings: CollectionNotificationSettingsInput!): CollectionNotificationSettings!
  unsubscribeNotification(subscriptionId: String!): Boolean!
  readNotifications(lastId: ID!): ReadNotifications!
  saveNotificationsSettings(settings: [SaveNotificationsSetting!]!): Boolean!
  adminAddNotification(userAddress: String!, data: NotificationTypeData!): Boolean!
  syncPearlsBotUser(initData: String!, walletType: String!): Boolean!
  togglePearlsSubscription(channelId: Int!): Boolean!
  reactionsNftAdd(address: String!, reaction: ReactionType!): Boolean! @deprecated(reason: "use addNftReaction")
  reactionsNftRemove(address: String!, reaction: ReactionType!): Boolean! @deprecated(reason: "use removeNftReaction")
  addNftReaction(address: String!, reaction: ReactionType!): ReactionsByNftAddress!
  removeNftReaction(address: String!, reaction: ReactionType!): ReactionsByNftAddress!
  ping: String!
  simpleTemporaryStorageSet(key: String!, value: String!): SimpleTemporaryStorageValue!
  tonTxCheckStatus(payload: CheckTxPayload!): TonTxStatus!
  tonTxCheckTonkeeperStatus(uuid: String!): TonTxTonkeeperStatus!
  tvUserOnboarding: Boolean!
  tvBuyEpisode(episodeId: Int!): TvPaymentResponse!
  tvBuySeries: TvPaymentResponse!
  tvRecordEpisodeView(episodeId: Int!): TvEpisode!
  tvSaveEvent(data: TvSaveEventPayload!): Boolean!
  createUploadUrl(image: ImageType!): String!
  nftVote(nftAddress: String!, key: String!): NftVotingResponse!
  nftCancelVote(nftAddress: String!): NftVotingResponse!
}

type User {
  id: ID!
  wallet: String!
  avatar: String!
  cover: String
  name: String!
  description: String
  socialLinks: [SocialLink!]!
  telegram: TelegramSettings!
  notificationsState: NotificationState!
  lang: UserLang!
  domain: String
  permissions: [UserPermission!]!
  isBurn: Boolean!
  isHiddenExist: Boolean!
  isCollectionCreator: Boolean!
  isBanned: Boolean
}

type NotificationState {
  count: Int!
}

type TelegramSettings {
  hasTelegram: Boolean!
  userName: String
  canSendMessage: Boolean!
}

enum UserPermission {
  User
  SuperAdmin
}

enum UserLang {
  en
  ru
}

input UserInput {
  avatarId: String
  coverId: String
  name: String
  description: String
  socialLinks: [SocialLinkInput!]
}

input LoginCredentialsInput {
  loginMessage: String!
  signedMessage: String!
  walletAddress: String!
  publicKey: String!
  walletVersion: String!
}

type TonKeeperAuthSource {
  isTonKeeperAuthSource: Boolean!
}

type WalletExtensionAuthSource {
  isWalletExtensionAuthSource: Boolean!
}

type TonConnectAuthSource {
  isTonConnectAuthSource: Boolean!
  storageJSON: String!
  storageVersion: Float!
}

union AuthSource = WalletExtensionAuthSource | TonKeeperAuthSource | TonConnectAuthSource

type AuthSession {
  authSource: AuthSource
  jwt: JWT
}

type Login {
  user: User!
  token: String!
  jwt: JWT!
}

enum AuthSourceType {
  Tonkeeper
  WalletExtension
  TonConnect
}

enum JWTVersion {
  V1
  V2
}

type JWTPayload {
  v: JWTVersion!
  wallet: String!
  auth: AuthSourceType!
  id: ID!
  maxMessages: Int!
}

type JWT {
  payload: JWTPayload!
  sign: String!
}

type UserBalance {
  value: String!
}

input TonConnectAuthPayload {
  address: String!
  chain: String!
  walletStateInit: String!
  publicKey: String
  timestamp: Float!
  domainLengthBytes: Int!
  domainValue: String!
  signature: String!
  payload: String!
  authApplication: String!
}

type AbsurdDropStatus {
  maxSpots: Int!
  totalSpots: Int!
  todayCheckins: Int!
}

type Query {
  me: User
  userByAddress(address: String!): User
  currentSession: AuthSession
  userBalance: UserBalance!
  absurdDropStatus(userAddress: String!): AbsurdDropStatus!
  featuredBanners(lang: UserLang!, page: String, preview: Boolean): [FeaturedBanner!]!
  rates(timestampSec: Int): Rates!
  dogSexGetMerge(mergeId: String!): DogSexMerge!
  dogSexHasRadioActiveNft: Boolean!
  checkGame(nftAddress: String!): GameReponse!
  bannerInfo(lang: UserLang!): BannerResponse!
  walletEggStatus: WalletEggStatus!
  walletEggActiveGames(first: Int!, after: String): WalletEggGameResponse!
  walletEggOverGames(userAddress: String, first: Int!, after: String): WalletEggGameResponse!
  walletEggStats: WalletEggStatistics!
  walletEggUserStat(userAddress: String!): WalletEggUserStatResponse!
  walletEggTop(type: WalletEggRatingType!, first: Int!, after: String): WalletEggTopResponse!
  walletEggUser(id: ID!): WalletEggUser!
  walletEggList(count: Int!, cursor: String, owner: String): WalletEggListResponse!
  walletEggGetById(eggId: ID!): WalletEgg!
  walletEggGameById(gameId: ID!): WalletEggGame!
  walletEggGameByEggId(eggId: ID!): WalletEggGame
  walletEggSaleSuggest(nftAddress: String!): WalletEggUserSaleSuggestResponse!
  walletEggGetTaskList: [WETask!]!
  getMyGemsWallet: GemsWalletAuth
  gemsWalletCheckAvatar(nftAddress: String!): Boolean!
  gemsWalletDapps(first: Int!, cursor: String): GemsWalletDappResponse!
  gemsWalletGetActiveRequest: GemsWalletRequest
  checkGetGemsDns(domain: String!): GetGemsDnsInfo!
  checkGetGemsDnsIsFree(domain: String!): GetGemsDnsStatus!
  getLinkedGetGemsDns(address: String!): GetLinkedGetGemsDnsResponse!
  getGetGemsDnsList(first: Int!, after: String): GetGetGemsDnsListResponse!
  launchpadItemBySlug(slug: String!, lang: UserLang): LaunchpadItem
  launchpadBillById(id: String!): LaunchpadBill
  launchpadStartNotificationSubscriptionStatus(launchpadItemId: String!): SaveLaunchpadStartNotificationSubscriptionStatus!
  launchpadReservedBillsBySlug(slug: String!, first: Int!, after: String): LaunchpadBills!
  lostDogsWayDailyGifts: LostDogsWayDailyGiftsResponse!
  lostDogsWayGameStatus: LostDogsWayGameStatusResponse!
  lostDogsWayWoofBoosterRateInfo: LostDogsWayWoofBoosterRateInfoResponse!
  lostDogsWayWoofPersonalTasks: LostDogsWayWoofPersonalTasksResponse!
  lostDogsWayGameDogsInfo: LostDogsWayGameDogsInfoResponse!
  lostDogsWayGameBoosts: LostDogsWayGameBoostsResponse!
  lostDogsWayVotesHistory: LostDogsWayVotesHistoryResponse!
  lostDogsWayCommonTasks: LostDogsWayCommonTasksResponse!
  lostDogsWayUserCommonTasksDone: [ID!]!
  lostDogsWayLeagueInfo(league: LostDogsWayLeagueName!, first: Int!): LostDogsWayLeagueInfoResponse!
  lostDogsWayUserLeagueInfo: LostDogsWayUserLeagueInfoResponse!
  lostDogsWayUserProfile: LostDogsWayUserProfileResponse!
  lostDogsWayUserInfo: LostDogsWayUserInfoResponse!
  lostDogsWayUserVotesHistory(first: Int!, after: String): LostDogsWayUserChoicesHistoryResponse!
  lostDogsWayUserReferralInfo: LostDogsWayUserReferralInfoResponse!
  lostDogsWayClaimStatus: LostDogsWayClaimStatusResponse!
  lostDogsWayMovieGameStatus: LostDogsWayMovieGameStatusResponse!
  lostDogsWayMovieDailyGifts: LostDogsWayMovieDailyGiftsResponse!
  lostDogsWayMovieGameNotcoinInfo: LostDogsWayMovieGameNotcoinInfoResponse!
  lostDogsWayMovieGameBoosts: LostDogsWayMovieGameBoostsResponse!
  lostDogsWayMovieUserCommonTasksDone: [ID!]!
  lostDogsWayMovieWoofPersonalTasks: LostDogsWayWoofPersonalTasksResponse!
  lostDogsWayMovieUserVotesHistory(first: Int!, after: String): LostDogsWayMovieUserChoicesHistoryResponse!
  lostDogsWayMovieUserInfo: LostDogsWayMovieUserInfoResponse!
  lostDogsWayMovieUserReferralInfo: LostDogsWayUserReferralInfoResponse!
  mainPageTopCollection(kind: MPTopKind!, first: Int!, after: String): MPCollectionTop!
  mainPageTopGift(kind: MPTopKind!, first: Int!, after: String): MPCollectionTop!
  nftCollectionByAddress(address: String!): NftCollection
  nftCategoryById(id: String): NftCategory
  nftTopCategoriesByCollectionAddress(address: String!, kind: NftCollectionCategoriesTopKind!, first: Int!, after: String): NftCategoryTop!
  alphaNftItemByAddress(address: String!): NftItem
  alphaNftItemsByAddressList(addressList: [String!]!): [NftItem!]!
  nftCollectionItems(address: String!, first: Int!, after: String): NftItemConnection!
  nftItemsByOwner(ownerAddress: String!, first: Int!, after: String): NftItemConnection!
  nftCollections(first: Int!, after: String, filter: FilterInput): NftCollectionConnection!
  nftItems(first: Int!, after: String, filter: FilterInput): NftItemConnection! @deprecated(reason: "nobody used it")
  nftSingles(first: Int!, after: String): NftItemConnection!
  nftSinglesByEditor(ownerAddress: String!, first: Int!, after: String): NftItemConnection!
  nftCollectionsByOwner(ownerAddress: String!, first: Int!, after: String): NftCollectionConnection!
  nftCollectionSales(collectionAddress: String!, first: Int): [NftItemSale!]!
  nftListWithUserOffer(userAddress: String!, first: Int!, after: String): NftItemConnection!
  draftNftCollectionsByUserId(userId: Int!, first: Int!, after: String): DraftNftCollectionsByUserId!
  draftNftItemsByUserId(userId: Int!, first: Int!, after: String): DraftNftItemsByUserId!
  resolveAddress(address: String!): ResolveAddressResult
  getAddressesOfVerifiedCollections: [String!]!
  adminActionsHistoryList(entityAddress: String!, first: Int!, after: String): AdminActionsHistoryListResponse!
  auctionsTop(type: AuctionsTopType!, first: Int!, after: String): NftItemConnection!
  getCurrencyInfo(currency: Currency!): CurrencyInfo!
  historyNftItem(address: String!, types: [HistoryType!], minTime: Int, maxTime: Int, first: Int!, after: String): NftItemHistoryConnection!
  historyCollectionNftItems(collectionAddress: String!, categoryId: String, types: [HistoryType!], minTime: Int, maxTime: Int, first: Int!, after: String): NftItemHistoryConnection!
  historySoldNftItem(address: String!): [NftItemHistory!]!
  historyCollectionSales(collectionAddress: String!, categoryId: String, daysCount: Int, timezoneOffset: Int): NftCollectionSalesConnection!
  ownerStatsNftCollection(collectionAddress: String!, categoryId: String, first: Int!, after: String): NftCollectionOwnerStatsConnection!
  statsNftCollection(collectionAddress: String!, categoryId: String): NftCollectionStatsCount!
  countHistoryNftCollection(collectionAddress: String!, categoryId: String, time: Int): NftItemHistoryCounts!
  countCollectionsNftsByUser(userAddress: String!, first: Int!, after: String): CollectionNftsCountConnection!
  collectionSalesTop(collectionAddress: String!, categoryId: String, first: Int!, date: String, after: String): NftItemHistoryConnection!
  nftCollectionDeployMessage(config: CollectionDeployParams!): SmcDeployMessageResponse! @deprecated
  singleNftDeployMessage(config: SingleNftDeployParams!): SmcDeployMessageResponse! @deprecated
  collectionsForDeployTo(cursor: String, count: Int): NftCollectionConnection! @deprecated(reason: "use getCreatedCollections")
  nftFixPriceSaleIsDeployed(saleAddress: String!): Boolean!
  nftFixPriceSaleDebugTransferRecommendedValue(nftAddress: String!): String!
  nftFixPriceSaleCalculateFee(nftAddress: String!, forChangePrice: Boolean): NftSaleFee!
  marketplaceFeeParams: MarketplaceFeeParams!
  nftAuctionBidHistory(auctionAddress: String!, cursor: String, first: Int!): NftAuctionBidHistory!
  nftOfferList(nftAddress: String!, first: Int!, cursor: String): NftOfferList!
  nftOfferListByCurrentUser(nftAddress: String, first: Int!, cursor: String): NftOfferList!
  getAvailableJettonsForSale(collectionAddress: String): [CurrencyInfo!]!
  collectionNotifications(collectionAddress: String!): CollectionNotificationSettings!
  nftNotifications(nftAddress: String!): CollectionNotificationSettings!
  collectionNotificationsList(first: Int!, after: String): CollectionNotificationsList!
  nftNotificationsList(first: Int!, after: String): NftNotificationsList!
  notificationsList(limit: Int!, cursor: String, lang: UserLang): NotificationsList!
  notificationsSettings(lang: UserLang): [NotificationsSettingsBlock!]!
  pearlsList(lang: UserLang!, first: Int!, after: String): PearlsListResponse!
  pearlsDropsList(lang: UserLang!, first: Int!, after: String): PearlsDropsListResponse!
  pearlsDropBySlug(lang: UserLang!, slug: String!): PearlsDropsItem
  pearlsDropsListByChannel(lang: UserLang!, channelId: Int!, first: Int!, after: String): PearlsDropsListResponse!
  pearlsChannelBySlug(lang: UserLang!, slug: String!): PearlsChannelsItem
  pearlsCheckUserSubscription(channelId: Int!): Boolean!
  pearlsChannelStats(slug: String!): PearlsChannelStatsResponse
  reactionsNft(address: String!, first: Int!, after: String): NftReactionsConnection!
  reactionsLikedNfts(uid: String!, first: Int!, after: String): NftItemConnection!
  reactionsByNftAddresses(uid: String!, addresses: [String!]!): ReactionsByNftAddresses!
  alphaNftItemSearch(query: String, sort: String, first: Int!, after: String, attributes: String): NftItemSearchConnection!
  alphaNftCollectionSearch(query: String, sort: String, first: Int!, after: String): NftCollectionSearchConnection!
  alphaNftCollectionStats(address: String!): NftCollectionStats
  alphaNftCollectionFilter(address: String!, query: String): NftCollectionFilter
  ping: String!
  mutantToadzStatus(initData: String!): MutantToadzStatus!
  tvEpisodes: TvEpisodesResponse!
  tvEpisodeVideo(episodeId: Int!): TvEpisodeVideoResponse!
  tvSeriesUserStatus: TvSeriesUserStatusResponse!
  tvPurchaseStatus(purchaseId: Int!): TvCheckPaymentResponse!
  userHistoryList(userAddress: String!, types: [HistoryDefinedIconType!], limit: Int!, cursor: String, lang: UserLang): UserHistoryList!
  userStats(userAddress: String!): UserStats
  userCounts(userAddress: String!): UserCounts
}

type FeaturedBanner {
  id: ID!
  image: String!
  video: String
  url: String!
  urlName: String
  badge: String
  title: String!
  description: String
  priority: Int
  gradientColor: String
}

enum SocialLinkType {
  Instagram
  Youtube
  Website
  Tiktok
  Discord
  TelegramChat
  TelegramBot
  TelegramChannel
  Twitter
  TelegramRu
  TelegramEn
  Ios
  Android
  VK
}

enum NftMintType {
  BuyNow
  DroppingSoon
  LimitedAuction
  OpenBids
}

enum FilterEntity {
  Collection
  Nft
}

enum FilterSort {
  AddedAtAsc
  AddedAtDesc
  PriceAsc
  PriceDesc
}

enum FilterListType {
  Whitelist
  Launched
}

enum FilterNftLocation {
  All
  InCollections
  SingleNfts
}

enum FilterStatus {
  All
  OnSale
  NotForSale
}

enum FilterApprove {
  Approved
  NotApproved
}

enum FilterVerified {
  Verified
  NotVerified
}

input SocialLinkInput {
  type: SocialLinkType!
  url: String!
}

type SocialLink {
  type: SocialLinkType!
  url: String!
}

type Rates {
  tonToUsd: Float!
  tonToRub: Float!
}

type Price {
  ton: Float!
  usd: Float!
  rub: Float!
}

input FilterInput {
  entity: FilterEntity
  sort: FilterSort
  listType: FilterListType
  priceRange: [Float]
  nftLocation: FilterNftLocation
  status: FilterStatus
  approve: FilterApprove
  verify: FilterVerified
}

type UserPreview {
  wallet: String!
  name: String
  avatar: String!
  domain: String
}

enum DogSexMergeStatus {
  wait
  done
  processing
  indexed
}

type DogSexMerge {
  id: ID!
  link: String!
  status: DogSexMergeStatus!
  leftNft: NftItem!
  leftUser: User!
  rightUser: User
  rightNft: NftItem
  leftNftChild: NftItem
  rightNftChild: NftItem
}

type DogSexStartResult {
  mergeId: ID!
  tx: TonTx!
}

type DogSexAcceptResult {
  merge: DogSexMerge!
  tx: TonTx
}

enum GameMove {
  Paper
  Rock
  Scissors
}

type MakeMove {
  roundEndsAt: Int!
}

type WaitingOpponent {
  roundEndsAt: Int!
  yourMove: GameMove
}

type WinRound {
  roundEndsAt: Int!
  yourMove: GameMove
  opponentMove: GameMove
  isRandomWin: Boolean!
}

type LoseRound {
  roundEndsAt: Int!
  yourMove: GameMove
  opponentMove: GameMove
  isRandomWin: Boolean!
}

type LosePrevRound {
  roundEndsAt: Int!
  loseAtRound: Int!
}

type DrawRound {
  roundEndsAt: Int!
  yourMove: GameMove
  prevMove: GameMove!
}

union RoundData = MakeMove | WaitingOpponent | WinRound | LoseRound | LosePrevRound | DrawRound

type GameRound {
  roundNum: Int!
  opponentUser: User
  opponentNft: NftItem
  isCounting: Boolean!
  roundCalculationStartsAt: Int!
  roundData: RoundData!
  yourNftAddress: String!
}

enum NftStateBeforeSale {
  Win
  Lose
}

type GameSale {
  nextRoundNum: Int!
  roundStartsAt: Int!
  roundCalculationStartsAt: Int!
  isCounting: Boolean!
  nftState: NftStateBeforeSale
  yourNftAddress: String!
}

type GameFinished {
  finishedAt: Int!
  yourNftAddress: String!
}

type GameRoundNotPrepared {
  roundNum: Int!
  roundEndsAt: Int!
  roundCalculationStartsAt: Int!
  yourNftAddress: String!
}

type NoGame {
  isNoGame: Boolean!
  state: GameState
}

union GameReponse = GameSale | GameRound | GameFinished | NoGame | GameRoundNotPrepared

enum GameState {
  Round
  Sale
  Finished
}

type GameStatsItem {
  key: String!
  value: String!
}

type BannerGameInfo {
  collection: NftCollection!
  roundNum: Int!
  roundStartsAt: Int!
  roundEndsAt: Int!
  roundCalculationStartsAt: Int!
  isLastRound: Boolean!
  text: String!
  link: String!
  state: GameState!
  finishedStats: [GameStatsItem]
  forSaleCount: Int
}

union BannerResponse = BannerGameInfo | NoGame

type MoveResponse {
  success: Boolean!
  errorMessage: String
  gameInfo: GameReponse!
}

enum GameSwitchState {
  Round
  Sale
  RoundCalc
  SaleCalc
  Finish
}

type Subscription {
  easterEggsState: GameReponse!
  easterEggsGameSwitchState: GameSwitchState!
  walletEggEvents: WalletEggEvent!
  gemsWalletEvents: GemsWalletEvent!
  lostDogsWayEvents: LostDogsWayEvents!
  nftItemWatch(nftAddress: String!): NftItemUpdateEvent!
  notificationsState(lang: UserLang): Notification!
  lifecheck: String!
}

type GameStateAwaitPlaying {
  finishAt: Int!
}

type GameStateTrading {
  finishAt: Int!
}

type GameStatePlaying {
  finishAt: Int!
}

type GameStateOver {
  linkForSome: String!
}

union WalletEggGameState = GameStateTrading | GameStatePlaying | GameStateAwaitPlaying | GameStateOver

type WalletEggGameBannerHeader {
  logo: String
  text: String!
}

type WalletEggGameBannerFooter {
  text: String!
  url: String!
}

type WalletEggGameBanner {
  header: WalletEggGameBannerHeader!
  content: String!
  bottom: WalletEggGameBannerFooter
}

type WalletEggStatus {
  hasWallet: Boolean! @deprecated(reason: "use walletAddress")
  walletAddress: String
  id: ID!
  prizeFund: String!
  eggsUrl: String!
  activeGamesCount: Int
  overGamesCount: Int
  gameState: WalletEggGameState!
  showTelegramLink: Boolean!
  collectionGetgemsLink: String!
  banner: WalletEggGameBanner
  hasRightWallet: Boolean!
  userLink: String!
  UQAddress: String!
  image: String!
}

enum WalletEggGameStatus {
  WaitLeftMove
  WaitRightMove
  WaitOpponent
  Draw
  LeftWin
  RightWin
  LeftOnSale
}

type WalletEggEventNewGame {
  gameId: ID!
  game: WalletEggGame!
}

type WalletEggEventDeleteGame {
  gameId: ID!
}

type WalletEggEventUpdateGame {
  gameId: ID!
  game: WalletEggGame!
}

type WalletEggEventUpdateCounters {
  activeGamesCount: Int
  overGamesCount: Int
}

type WalletEggEventUpdateGameState {
  gameState: WalletEggGameState!
}

type WalletEggEventUpdateBanner {
  newBanner: WalletEggGameBanner
}

union WalletEggEvent = WalletEggEventNewGame | WalletEggEventDeleteGame | WalletEggEventUpdateGame | WalletEggEventUpdateCounters | WalletEggEventUpdateGameState | WalletEggEventUpdateBanner

type WalletEggUser {
  id: ID!
  name: String!
  image: String!
  link: String
  winsCount: Int!
  gamesCount: Int!
}

type WalletEggGameItem {
  image: String!
  user: WalletEggUser!
  eggName: String!
  eggAddress: String!
  isWinner: Boolean!
  isBroken: Boolean!
  claimed: Boolean!
  move: GameMove
}

type WalletEggGamePrev {
  leftMove: GameMove!
  rightMove: GameMove!
}

type WalletEgg {
  id: ID!
  image: String!
  name: String!
  link: String!
  level: Int!
  isBroken: Boolean!
  claimed: Boolean!
  price: Float
  canPutOnSale: Boolean!
}

type WalletEggListResponse {
  items: [WalletEgg!]!
  cursor: String
}

enum WalletEggGameBottomText {
  LastDrawAttempt
  TooManyDraws
  RandomWinnerAfterTimeout
  LeftLooseAfterTimeout
  LeftWinAfterTimeout
  LeftOnSale
}

type WalletEggGame {
  id: ID!
  status: WalletEggGameStatus!
  bottomText: WalletEggGameBottomText
  checkGlobalStatus: Boolean!
  round: Int!
  timer: Int
  left: WalletEggGameItem!
  right: WalletEggGameItem
  prevGames: [WalletEggGamePrev!]
  attempt: Int!
  isLastAttempt: Boolean!
  isRandomWinner: Boolean!
}

type WalletEggGameResponse {
  games: [WalletEggGame!]!
  cursor: String
}

enum WalletEggRatingType {
  wins
  winrate
  games
}

type WalletEggRatingData {
  value: Float!
  position: Int!
}

type WalletEggUserStatRatings {
  wins: WalletEggRatingData
  winrate: WalletEggRatingData
  games: WalletEggRatingData
}

type WalletEggUserStatResponse {
  wins: WalletEggRatingData!
  games: WalletEggRatingData!
  winrate: WalletEggRatingData!
  user: WalletEggUser!
}

type WalletEggTop {
  id: Int!
  rating: WalletEggRatingData!
  user: WalletEggUser!
}

type WalletEggTopResponse {
  cursor: String
  data: [WalletEggTop!]!
}

input WEOpponentProfileClicked {
  source: String!
  opponentId: String!
}

input WalletEggFrontEvent {
  timeMs: Float!
  launch: Boolean
  connectTonWalletClicked: Boolean
  walletConnected: Boolean
  tutorialFirstRoundDone: Boolean
  tutorialSecondRoundDone: Boolean
  myEggsClicked: Int
  ratingClicked: Boolean
  getMoreEggsClicked: Int
  letsStartClicked: Boolean
  sellBannerClicked: Int
  joinChatClicked: Boolean
  tradeClicked: Int
  myProfileClicked: Boolean
  opponentProfileClicked: WEOpponentProfileClicked
  ratingNavigationClicked: String
  showMyTelegramToggler: Boolean
}

input WalletEggSaleEventUtm {
  source: String
  medium: String
  campaign: String
  term: String
  content: String
}

input WalletEggSaleEvent {
  events: [WalletEggFrontEvent!]!
  utm: WalletEggSaleEventUtm
}

type WalletEggUserSaleSuggestResponse {
  recommendedPrice: Float!
  minPrice: Float!
  serviceFeePercent: Float!
  serviceFeeMin: Float!
}

type WalletEggGenerationBuyButton {
  enabled: Boolean!
  url: String!
}

type WalletEggGenerationSellButton {
  enabled: Boolean!
}

union WalletEggGenerationButton = WalletEggGenerationBuyButton | WalletEggGenerationSellButton

type WalletEggStatisticsMove {
  move: GameMove!
  count: Int!
}

type WalletEggStatisticsGeneration {
  level: Int!
  count: Int!
  minPrice: String
  buttons: [WalletEggGenerationButton!]!
}

type WalletEggStatistics {
  users: Int!
  eggsInGame: Int!
  eggsBroken: Int!
  salesInTon: String!
  sales: Int!
  popularMove: WalletEggStatisticsMove
  generations: [WalletEggStatisticsGeneration]!
}

enum WETaskCode {
  WETaskInviteFriend
  WETaskDalyFreeEgg
  WETaskConnectWallet
}

type WETaskResult {
  done: Boolean!
  rejectReasonText: String
  newEggs: Int
}

type WETaskInviteFriend {
  title: String!
  description: String!
  status: String
  copyLink: String!
}

type WETaskDalyFreeEgg {
  title: String!
  description: String!
}

type WETaskConnectWallet {
  title: String!
  description: String!
}

type WETaskBuyOnGetgems {
  title: String!
  description: String!
  url: String!
}

union WETask = WETaskDalyFreeEgg | WETaskInviteFriend | WETaskConnectWallet | WETaskBuyOnGetgems

enum GemsWalletAuthType {
  vk
  tg
}

type GemsWallet {
  address: String!
}

enum GemsWalletAvatarStatus {
  empty
  loading
  done
}

type GemsWalletAuth {
  type: GemsWalletAuthType!
  accountId: String!
  wallet: GemsWallet!
  walletList: [GemsWallet!]!
  freeAvatarStatus: GemsWalletAvatarStatus!
  freeAvatarNftAddress: String
  notifyVkGroupId: Int!
  notificationEnabled: Boolean!
}

input GemsWalletImage {
  imageId: String
  imageUrl: String
}

type GemsWalletAvatarResponse {
  nftAddress: String!
}

type GemsWalletConnectResult {
  url: String!
  name: String!
  iconUrl: String!
  returnUrl: String!
  wallet: String!
  connectPayload: String!
}

type GemsWalletDapp {
  id: ID!
  name: String!
  url: String!
  iconUrl: String!
  createdAt: Float!
}

type GemsWalletDappResponse {
  items: [GemsWalletDapp!]!
  cursor: String
}

type GemsWalletRequestTransactionMessage {
  toAddress: String!
  amount: String!
  fee: String!
}

enum GemsWalletRequestTransactionFailReason {
  lowBalance
  txForAnotherWallet
}

type GemsWalletRequestTransaction {
  id: ID!
  dapp: GemsWalletDapp!
  wallet: String!
  totalAmount: String!
  balanceBefore: String!
  balanceAfter: String!
  canSend: Boolean!
  failReason: GemsWalletRequestTransactionFailReason
  messages: [GemsWalletRequestTransactionMessage!]!
}

type GemsWalletRequestNever {
  id: ID!
  never: Boolean!
}

union GemsWalletRequest = GemsWalletRequestNever | GemsWalletRequestTransaction

type GemsWalletEventAvatarReady {
  nftAddress: String!
}

type GemsWalletEventTonConnect {
  request: GemsWalletRequest!
}

union GemsWalletEvent = GemsWalletEventTonConnect | GemsWalletEventAvatarReady

type GetGemsDnsInfoUser {
  address: String!
}

type GetGemsDnsInfoNft {
  address: String!
  collectionAddress: String
}

type GetGemsDnsInfoCollection {
  address: String!
}

type GetGemsDnsInfoNotExist {
  exist: Boolean!
}

union GetGemsDnsInfo = GetGemsDnsInfoNft | GetGemsDnsInfoCollection | GetGemsDnsInfoUser | GetGemsDnsInfoNotExist

type GetGemsDnsStatusFree {
  minBid: String!
  name: String!
  imageUrl: String!
}

type GetGemsDnsStatusOccupied {
  nft: NftItem!
}

union GetGemsDnsStatus = GetGemsDnsStatusFree | GetGemsDnsStatusOccupied

type LinkedGetGemsDnsItem {
  id: String!
  domain: String!
}

type GetLinkedGetGemsDnsResponse {
  items: [LinkedGetGemsDnsItem!]
  cursor: String
}

union LinkedGetGemsDnsEntity = NftCollection | NftItem | User

type GetGemsDnsNft {
  item: NftItem!
  linkedEntity: LinkedGetGemsDnsEntity
}

type GetGetGemsDnsListResponse {
  items: [GetGemsDnsNft!]
  cursor: String
}

enum LaunchpadItemStatus {
  NOT_STARTED
  IN_PROGRESS
  FINISHED
}

enum LaunchpadItemBadgeType {
  PRICE
  MINT_TYPE
  LIMIT
  CUSTOM
}

type LaunchpadItemBadgeTypeDataPrice {
  type: LaunchpadItemBadgeType!
  price: String!
}

enum LaunchpadMintType {
  PUBLIC
  WHITELIST
}

type LaunchpadItemBadgeTypeDataMintType {
  type: LaunchpadItemBadgeType!
  mintType: LaunchpadMintType!
}

enum LaunchpadLimit {
  UNLIMITED
}

type LaunchpadItemBadgeTypeDataLimit {
  type: LaunchpadItemBadgeType!
  limit: LaunchpadLimit!
}

type LaunchpadItemBadgeTypeDataCustom {
  type: LaunchpadItemBadgeType!
  text: String!
  url: String
}

union LaunchpadItemBadgeTypeData = LaunchpadItemBadgeTypeDataPrice | LaunchpadItemBadgeTypeDataMintType | LaunchpadItemBadgeTypeDataLimit | LaunchpadItemBadgeTypeDataCustom

type LaunchpadItemBadge {
  typeData: LaunchpadItemBadgeTypeData!
}

type LaunchpadItemPriceValue {
  value: String!
}

type NeedsAuth {
  needsAuth: Boolean
}

type DisabledByWhitelist {
  isDisabled: Boolean
}

type DisabledByCollectionOwning {
  isDisabled: Boolean
}

union LaunchpadItemPrice = NeedsAuth | LaunchpadItemPriceValue | DisabledByWhitelist | DisabledByCollectionOwning

type Media {
  id: String!
  image: String!
  video: String
}

type LaunchpadItem {
  id: ID!
  title(lang: UserLang): String!
  status: LaunchpadItemStatus!
  description(lang: UserLang): String
  images: [Image!] @deprecated(reason: "use media")
  media: [Media!]
  collectionAddress: String
  socialLinks: [SocialLink!]
  itemsCountTotal: Int
  soldCount: Int!
  finishAt: Int
  startAt: Int
  price: LaunchpadItemPrice
  markdown(lang: UserLang): String
  badges(lang: UserLang): [LaunchpadItemBadge!]
  maxNftCountPerTransaction: Int!
}

enum LaunchpadBillStatus {
  NEW
  PROCESSED
  ERROR
  EXPIRED
}

type LaunchpadBill {
  id: String!
  status: LaunchpadBillStatus!
  addressList: [String!]!
  nfts: [NftItem!]
  valueTon: String!
  tx: TonTx!
  expireAt: Int!
  amountNft: Int!
}

type SaveLaunchpadStartNotificationSubscriptionStatus {
  isSubscribed: Boolean!
}

type LaunchpadBills {
  items: [LaunchpadBill!]!
  cursor: String
}

type LostDogsWayDailyGift {
  id: ID!
  title: String!
  description: String!
  image: String!
  url: String
  isNft: Boolean
  isBooster: Boolean
}

type LostDogsWayDailyTier {
  title: String!
  description: String!
  image: String!
  url: String!
}

type LostDogsWayDailyGiftsResponse {
  items: [LostDogsWayDailyGift!]!
  tier: LostDogsWayDailyTier!
}

type LostDogsWayRoundCard {
  id: String!
  number: Int!
  value: String!
  name: String!
  image: String!
}

type LostDogsWayGameStatusInactive {
  _: Boolean
}

type LostDogsWayGameStatusFinished {
  _: Boolean
}

type LostDogsWayGameStatusCalculation {
  calculationEndsAt: Int!
  gameEndsAt: Int!
}

enum LostDogsWayRoundTaskType {
  smallest
  average
  biggest
}

type LostDogsWayGameStatusRound {
  id: ID!
  taskType: LostDogsWayRoundTaskType!
  roundCards: [LostDogsWayRoundCard!]!
  roundEndsAt: Int!
  gameEndsAt: Int!
  description: String!
  isGrandRound: Boolean
  notcoinBank: String!
}

union LostDogsWayGameStatus = LostDogsWayGameStatusInactive | LostDogsWayGameStatusCalculation | LostDogsWayGameStatusRound | LostDogsWayGameStatusFinished

type LostDogsWayGameStatusResponse {
  gameState: LostDogsWayGameStatus!
}

type LostDogsWayStatus {
  walletAddress: String
  userId: ID!
}

enum LostDogsWayVoteChangeBoostStatus {
  required
  obtained
  used
}

type LostDogsWayCurrentRoundVote {
  id: ID!
  selectedRoundCardValue: String!
  spentGameDogsCount: String!
  isVoteChangeBoostAvailable: Boolean! @deprecated(reason: "use voteChangeBoostStatus")
}

type LostDogsWayUserInfoResponse {
  woofBalance: String!
  gameDogsBalance: String!
  currentRoundVote: LostDogsWayCurrentRoundVote
  prevRoundVote: LostDogsWayUserRoundVote
  squad: LostDogsWayUserSquad
  exchangeDone: Boolean!
  storyDone: Boolean!
  referralLink: String!
}

type LostDogsWayWoofBoosterRate {
  daysInARow: Int!
  rateValue: String!
}

type LostDogsWayWoofBoosterRateInfoResponse {
  userRate: String!
  userRateDay: Int!
  rates: [LostDogsWayWoofBoosterRate!]!
}

type LostDogsWayPersonalTask {
  id: ID!
  name: String!
  description: String!
  isCompleted: Boolean!
  type: LostDogsWayUserTaskType!
  url: String
}

type LostDogsWayWoofPersonalTasksResponse {
  items: [LostDogsWayPersonalTask!]!
}

type LostDogsWayGameDogsInfoNotcoin {
  dogPrice: String!
  maxDogCountPerTx: Int!
}

type LostDogsWayGameDogsInfoStar {
  options: [LostDogsWayGameDogsStarOption!]!
  isBought: Boolean!
}

type LostDogsWayGameDogsStarOption {
  count: Int!
  dogPrice: Int!
}

union LostDogsWayGameDogsInfo = LostDogsWayGameDogsInfoNotcoin | LostDogsWayGameDogsInfoStar

type LostDogsWayGameDogsInfoResponse {
  data: LostDogsWayGameDogsInfo!
}

type LostDogsWayGameBoost {
  id: ID!
  type: LostDogsWayBoostType!
  name: String!
  image: String!
  price: String!
  description: String!
  voteChangeBoostStatus: LostDogsWayVoteChangeBoostStatus!
  isBought: Boolean! @deprecated(reason: "use voteChangeBoostStatus")
}

type LostDogsWayGameBoostsResponse {
  items: [LostDogsWayGameBoost!]!
}

enum LostDogsWayLeagueName {
  bronze
  silver
  gold
  platinum
  diamond
  bone
}

type LostDogsWayUser {
  id: ID!
  nickname: String!
  avatar: String
}

type LostDogsWayWalletStatus {
  id: ID!
  notBalance: String!
  isNotBalanceClaimable: Boolean!
  connectedWalletAddress: String
}

type LostDogsWayUserSquad {
  name: String!
  logoUrl: String!
  id: String!
}

type LostDogsWayUserProfileResponse {
  user: LostDogsWayUser!
  walletStatus: LostDogsWayWalletStatus!
}

type LostDogsWayLeagueMember {
  user: LostDogsWayUser!
  woofBalance: String!
  correctVotesCount: Int!
  place: Int!
}

type LostDogsWayLeagueInfoResponse {
  name: LostDogsWayLeagueName!
  minWoofCount: String
  maxWoofCount: String
  members: [LostDogsWayLeagueMember!]!
}

type LostDogsWayUserLeagueInfoResponse {
  name: LostDogsWayLeagueName!
  user: LostDogsWayLeagueMember
}

type LostDogsWayRoundCardWithResults {
  id: String!
  card: LostDogsWayRoundCard!
  votesPercent: Int!
  isWinner: Boolean!
  description: String!
  dogsCount: Int!
}

type LostDogsWayRoundVote {
  date: Int!
  taskType: LostDogsWayRoundTaskType!
  roundCards: [LostDogsWayRoundCardWithResults!]!
}

type LostDogsWayVotesHistoryResponse {
  items: [LostDogsWayRoundVote!]!
}

enum LostDogsWayUserRoundVoteStatus {
  winner
  loser
  skipped
}

type LostDogsWayPossiblePaidReward {
  notcoinAmount: String!
  notcoinReward: String!
}

type LostDogsWayUserRoundVote {
  date: Int!
  taskType: LostDogsWayRoundTaskType!
  userStatus: LostDogsWayUserRoundVoteStatus!
  selectedRoundCardValue: String
  notPrize: String
  woofPrize: String
  cards: [LostDogsWayRoundCardWithResults!]!
  possiblePaidReward: LostDogsWayPossiblePaidReward
}

type LostDogsWayUserChoicesHistoryResponse {
  cursor: String
  items: [LostDogsWayUserRoundVote!]!
}

type LostDogsWayUserReferralInfoResponse {
  invitedPeopleCount: Int!
  referralLink: String!
}

enum LostDogsWayCustomCheckStrategy {
  notEmptyWallet
  adsGram
}

type LostDogsWayCommonTask {
  id: ID!
  name: String!
  description: String!
  image: String!
  url: String!
  woofReward: String!
  dogReward: Int!
  customCheckStrategy: LostDogsWayCustomCheckStrategy
}

type LostDogsWayCommonTasksResponse {
  items: [LostDogsWayCommonTask!]!
}

type LostDogsWayCompleteCommonTasksResponse {
  success: Boolean!
  task: LostDogsWayCommonTask
}

type LostDogsWayCompleteTasksResponse {
  success: Boolean!
  task: LostDogsWayPersonalTask
  woofReward: String
}

enum LostDogsWayUserTaskType {
  onboarding
  firstBid
  joinSquad
  woofScreen
  findMyDogs
  firstBuyDogs
  connectWallet
  findTop
  sharing
}

enum LostDogsWayState {
  calculation
  round
  finished
}

enum LostDogsWayBoostType {
  revote
  x2woof
}

type StarsTx {
  url: String!
  check: String!
}

type LostDogsWayGameStatusChange {
  newStatus: LostDogsWayState!
}

enum LostDogsWayApplyNotEmptyWalletStatus {
  success
  walletNotConnected
  insufficientFunds
  highload
}

type LostDogsWayApplyNotEmptyWalletResponse {
  status: LostDogsWayApplyNotEmptyWalletStatus!
  commonTask: LostDogsWayCommonTask
}

union LostDogsWayEvents = LostDogsWayGameStatusChange | LostDogsWayGameDogsInfoResponse

enum LostDogsWayEventPage {
  onboarding1
  onboarding2
  onboarding3
  onboarding4
  onboarding5
  onboarding6
  woof
  yourDog
}

input LostDogsWayFrontEvent {
  timeMs: Float!
  launch: Boolean
  onboardingContinue: Boolean
  mainScreenVote: Boolean
  mainScreenMyLeague: Boolean
  profileClaimNot: String
  profilePreviousChoice: Boolean
  profileInviteFriendsButton: Boolean
  profileInviteFriendsCopy: Boolean
  profileInviteFriendsShare: Boolean
  profileJoinChat: Boolean
  profileJoinChannel: Boolean
  yourDogBuyDogsBuyButton: Int
  yourDogBoostX2WOOFButton: Boolean
  yourDogBoostX2WOOFBuyButton: Boolean
  yourDogBoostChangeVoteButton: Boolean
  yourDogBoostChangeVoteBuyButton: Boolean
  yourDogGetFreeDogs: Boolean
  voteBuyMoreDogs: Boolean
  voteConfirmChoice: Boolean
  voteChangeVote: Boolean
  voteReadLore: Boolean
  voteJoinChat: Boolean
  voteJoinChannel: Boolean
  voteBuyChangeVote: Boolean
  woofGetFreeDogs: Boolean
  commonPageView: LostDogsWayEventPage
}

input LostDogsWayFrontEventUtm {
  source: String
  medium: String
  campaign: String
  term: String
  content: String
}

input LostDogsWaySaveEventPayload {
  events: [LostDogsWayFrontEvent!]!
  utm: LostDogsWayFrontEventUtm
}

type LostDogsWayCompleteAdsGramTasksResponse {
  success: Boolean!
  task: LostDogsWayCommonTask
  watchMore: Boolean!
}

enum LostDogsWayClaimStep {
  exchangeForm
  beforeClaim
  kycDone
  claim
}

enum LostDogsWayClaimProgress {
  idle
  exchange
  chain
}

type LostDogsWayUserClaimStatus {
  isBanned: Boolean!
  banReason: String
  claimProgress: LostDogsWayClaimProgress!
  kyc: Boolean!
  claimedWoofAmount: String!
  exceedsLimit: Boolean!
  minClaimAmount: String!
  depositAddress: String
  memo: String
  woofBalance: String!
  walletAddress: String
  isFromUSA: Boolean!
}

type LostDogsWayClaimStatusResponse {
  step: LostDogsWayClaimStep!
  status: LostDogsWayUserClaimStatus!
  userExists: Boolean!
}

type LostDogsWaySaveExchangeFormResponse {
  status: LostDogsWayUserClaimStatus!
}

input LostDogsWaySaveExchangeFormPayload {
  depositAddress: String
  memo: String
  walletAddress: String
}

type LostDogsWayMovieSeries {
  url: String!
  seriesNum: Int!
  preview: String!
  name: String!
}

type LostDogsWayMovieGameStatusRound {
  id: ID!
  roundCards: [LostDogsWayRoundCard!]!
  roundEndsAt: Int!
  gameEndsAt: Int!
  isBlockchainSlow: Boolean!
  auctionUrl: String!
  tvAppUrl: String!
  notcoinBank: String!
  question: String!
}

type LostDogsWayMovieGameStatusCalculation {
  calculationEndsAt: Int!
  gameEndsAt: Int!
  movie: LostDogsWayMovieSeries!
  isBlockchainSlow: Boolean!
  tvAppUrl: String!
  question: String!
}

union LostDogsWayMovieGameStatus = LostDogsWayGameStatusInactive | LostDogsWayMovieGameStatusCalculation | LostDogsWayMovieGameStatusRound | LostDogsWayGameStatusFinished

type LostDogsWayMovieGameStatusResponse {
  gameState: LostDogsWayMovieGameStatus!
}

type LostDogsWayMovieGameNotcoinInfoResponse {
  maxAmount: String!
  existNotcoinAmount: String
  woofWinFree: String!
  woofWinPaid: String!
}

type LostDogsWayRoundMovieCardWithResults {
  id: String!
  card: LostDogsWayRoundCard!
  votesPercent: Int!
  isWinner: Boolean!
  description: String!
  notcoinAmount: String!
}

type LostDogsWayMovieRoundVote {
  date: Int!
  roundCards: [LostDogsWayRoundMovieCardWithResults!]!
}

type LostDogsWayMovieVotesHistoryResponse {
  items: [LostDogsWayMovieRoundVote!]!
}

type LostDogsWayMovieUserChoicesHistoryResponse {
  cursor: String
  items: [LostDogsWayMovieUserRoundVote!]!
}

type LostDogsWayMovieUserRoundVote {
  date: Int!
  userStatus: LostDogsWayUserRoundVoteStatus!
  selectedRoundCardValue: String
  notPrize: String
  woofPrize: String
  cards: [LostDogsWayRoundMovieCardWithResults!]!
  possiblePaidReward: LostDogsWayPossiblePaidReward
}

type LostDogsWayMovieCurrentRoundVote {
  id: ID!
  selectedRoundCardValue: String!
  spentNotcoins: String
}

type LostDogsWayMovieDailyGiftsResponse {
  items: [LostDogsWayDailyGift!]!
}

enum LostDogsWayMovieBoostType {
  random_pic
  x2woof
  credits_place
  revote
}

type LostDogsWayMovieGameBoost {
  id: ID!
  type: LostDogsWayMovieBoostType!
  name: String!
  image: String!
  price: String!
  description: String!
  voteChangeBoostStatus: LostDogsWayVoteChangeBoostStatus!
  isCreditsPlace: Boolean!
}

type LostDogsWayMovieGameBoostsResponse {
  items: [LostDogsWayMovieGameBoost!]!
}

type LostDogsWayMovieUserInfoResponse {
  woofBalance: String!
  currentRoundVote: LostDogsWayMovieCurrentRoundVote
  prevRoundVote: LostDogsWayMovieUserRoundVote
  exchangeDone: Boolean!
  storyDone: Boolean!
  referralLink: String!
}

input LostDogsWayMovieEventCommon {
  screen: String!
}

input LostDogsWayMovieEventClaimNot {
  notAmount: String!
  screen: String!
}

input LostDogsWayMovieFrontEvent {
  timeMs: Float!
  launch: Boolean
  watchPreviousEpisodes: LostDogsWayMovieEventCommon
  confirmChoice: LostDogsWayMovieEventCommon
  payForCard: LostDogsWayMovieEventCommon
  boostX2Woof: LostDogsWayMovieEventCommon
  boostChangeVote: LostDogsWayMovieEventCommon
  inviteFriendsCopy: LostDogsWayMovieEventCommon
  inviteFriendsShare: LostDogsWayMovieEventCommon
  watchTVonTG: LostDogsWayMovieEventCommon
  boostRandomFrame: LostDogsWayMovieEventCommon
  boostPlaceInCredits: LostDogsWayMovieEventCommon
  claimNOT: LostDogsWayMovieEventClaimNot
  pageView: LostDogsWayMovieEventCommon
  onboardingContinue: Boolean
}

input LostDogsWayMovieSaveEventPayload {
  events: [LostDogsWayMovieFrontEvent!]!
  utm: LostDogsWayFrontEventUtm
}

enum CacheControlScope {
  PUBLIC
  PRIVATE
}

enum MPTopKind {
  day
  week
  month
  all
}

enum CurrencyType {
  rub
  usd
}

type MPCollectionTopItem {
  place: Int!
  tonValue: String!
  currencyValue(currency: CurrencyType!): Float!
  diffPercent: Float
  floorPrice: Float!
  currencyFloorPrice(currency: CurrencyType!): Float!
  collection: NftCollection!
}

type MPCollectionTop {
  cursor: String
  items: [MPCollectionTopItem!]!
}

type RoyaltyParams {
  royaltyFactor: Int!
  royaltyBase: Int!
  royaltyAddress: String!
}

type NftCollection {
  id: ID!
  address: String!
  ownerAddress: String!
  owner: User!
  name: String
  description: String
  royaltyParams: RoyaltyParams
  image: NftContentImage
  coverImage: NftContentImage
  rawMetadata: String!
  socialLinks: [String!]
  isApproved: Boolean
  priority: Int! @deprecated(reason: "never selected")
  isBlocked: Boolean
  isVerified: Boolean
  isRarityValid: Boolean
  hasRarityAttributes: Boolean
  hasCategories: Boolean
  isRarityEnabled: Boolean
  approximateItemsCount: Int!
  approximateHoldersCount: Int!
  domain: String
  isGetGemsDnsCollection: Boolean
  isBadSalesHidden: Boolean
  isAllowJettonSales: Boolean
  floorPrice: Float @deprecated(reason: "never worked")
  isAgeRestrict: Boolean
}

type DraftNftCollectionWithBlocked {
  id: ID!
  address: String!
  name: String!
  userId: Int!
  isBlocked: Boolean!
  createdAt: String!
}

type DraftNftItemWithBlocked {
  id: ID!
  name: String!
  address: String!
  userId: Int!
  isBlocked: Boolean!
  createdAt: String!
}

enum LayoutType {
  Default
  WideAsPossible
}

type Image {
  baseUrl: String!
  sized(width: Int!, height: Int!, format: String): String!
  video(width: Int!, height: Int!): String! @deprecated
  hasAnimation: Boolean! @deprecated(reason: "will be always failed")
  animation(width: Int!, height: Int!): String @deprecated(reason: "will be never return")
  preview(width: Int!, height: Int!): String
  layout: LayoutType!
}

type NftCategory {
  id: ID!
  collectionAddress: String!
  name: String!
  image: String!
  descriptionRu: String
  descriptionEn: String
  floorPrice: Float
  tonValue: String
  approximateItemsCount: Int!
  approximateHoldersCount: Int!
}

type NftCategoryConnection {
  items: [NftCategory]!
  cursor: String
}

type NftCategoryTopItem {
  place: Int!
  tonValue: String!
  currencyValue(currency: CurrencyType!): Float!
  diffPercent: Float
  floorPrice: Float!
  currencyFloorPrice(currency: CurrencyType!): Float!
  category: NftCategory!
}

type NftCategoryTop {
  cursor: String
  items: [NftCategoryTopItem!]!
}

union NftContent = NftContentImage | NftContentNotLoaded | NftContentLottie | NftContentVideo

type NftContentNotLoaded {
  notLoaded: Boolean!
}

type NftContentImage {
  image: Image!
  originalUrl: String
}

type NftContentLottie {
  lottie: String!
  image: Image
}

type NftContentVideo {
  baseUrl: String!
  sized(width: Int!, height: Int!, format: String): String!
  preview(width: Int!, height: Int!): String
}

enum NftContentSourceType {
  GetGems
  Ipfs
  Decentralized
  Centralized
  OnChain
  TonStorage
}

enum NftAttributeDisplayType {
  Number
  BoostPercentage
  BoostNumber
  Date
}

type NftAttribute {
  traitType: String!
  value: String!
  displayType: NftAttributeDisplayType
}

enum Currency {
  TON
  USDT
  NOT
  SNT
  DFC
  VAT
  NOTTEST
  FTON
  GTON
  WOOF
  DOGS
  PX
}

union NftSale = NftSaleFixPrice | NftSaleFixPriceDisintar | NftSaleAuction | TelemintAuction

type NftSaleFixPrice {
  address: String!
  nftOwnerAddress: String!
  fullPrice: String!
  marketplaceFeeAddress: String!
  marketplaceFee: String!
  royaltyAddress: String!
  royaltyAmount: String!
  networkFee: String
  currency: Currency!
}

type NftSaleFixPriceDisintar {
  address: String!
  nftOwnerAddress: String!
  fullPrice: String!
  marketplaceFeeAddress: String!
  marketplaceFee: String!
  royaltyAddress: String!
  royaltyAmount: String!
  networkFee: String
}

type NftSaleAuction {
  address: String!
  nftOwnerAddress: String!
  marketplaceFeeAddress: String!
  marketplaceFeePercent: Float!
  royaltyAddress: String!
  royaltyPercent: Float!
  minBid: String!
  maxBid: String
  minStep: String!
  stepIsPercent: Boolean!
  isCancelable: Boolean!
  minNextBid: String!
  end: Boolean!
  finishAt: Int!
  lastBidAmount: String
  lastBidAmountWithFee: String
  lastBidAddress: String
  lastBidUser: User
  lastBidAt: Int
  version: AuctionVersion!
  cancelButton: Boolean!
  finishButton: Boolean!
  networkFee: String
  currency: Currency!
}

type TelemintAuction {
  lastBidAmount: String!
  lastBidAddress: String
  lastBidUser: User
  lastBidAt: Int!
  nextBidAmount: String!
  maxBidAmount: String
  isFixPrice: Boolean!
  finishAt: Int!
  link: String
  royaltyPercent: Float!
  marketplaceFeePercent: Float!
  isGetGemsDns: Boolean
}

type RarityAttribute {
  traitType: String!
  value: String
  maxShapeCount: Int!
  rarityPercent: String!
}

enum NftItemKind {
  Single
  CollectionItem
  DnsItem
  SbtItem
  SbtSingle
  SyntheticItem
}

type NftPageLayoutDogSex {
  isDogSex: Boolean!
  parents: [NftItem!]!
  mergeCount: Int
}

type NftPageLayoutEasterEggs {
  isEasterEggs: Boolean!
}

type NftVotingVariant {
  text(lang: UserLang): String!
  key: String!
  isChecked: Boolean!
  statsCount: Int!
  statsPercent: String!
}

type NftPageLayoutVoting {
  title(lang: UserLang): String!
  description(lang: UserLang): String!
  startAt: Int!
  finishAt: Int!
  isVoted: Boolean!
  isVoteable: Boolean!
  isNeedToMint: Boolean!
  isFinished: Boolean!
  variants: [NftVotingVariant!]!
}

union NftPageLayout = NftPageLayoutDogSex | NftPageLayoutEasterEggs | NftPageLayoutVoting

union NftObject = NftCollection | User | NftItem

type NftLinkButton {
  linkedTo: NftObject
  unlinkButton: Boolean!
  linkButton: Boolean!
  slug: String!
  isShortUrl: Boolean!
}

enum NftItemButtonDisplayTo {
  All
  Owner
  NotOwner
  Nobody
}

type NftItemButton {
  displayTo: NftItemButtonDisplayTo!
}

type NftItemButtons {
  putOnSale: NftItemButton!
  putOnAuction: NftItemButton!
  makeOffer: NftItemButton!
  transferNft: NftItemButton!
  buyNft: NftItemButton!
  makeBid: NftItemButton!
  mintCNft: NftItemButton!
}

type NftBanFromFragment {
  reason: String!
}

union NftWarningBanner = NftBanFromFragment

type NftItem {
  id: ID!
  address: String!
  ownerAddress: String!
  owner: User!
  collection: NftCollection
  version: String!
  index: Float!
  editorAddress: String
  name: String
  description: String
  content: NftContent!
  attributes: [NftAttribute!]!
  rawMetadata: String! @deprecated(reason: "field will be removed")
  metadataSourceType: NftContentSourceType!
  contentSourceType: NftContentSourceType!
  sale: NftSale
  isApproved: Boolean
  priority: Int!
  isBlocked: Boolean
  warningBanner: NftWarningBanner
  reactionCounters: ReactionCounter
  rarityRank: Int
  rarityAttributes: [RarityAttribute!]
  kind: NftItemKind!
  maxOffer: NftOffer
  isRevealable: Boolean!
  actionButtons: [ActionButton!]!
  showButtons: NftItemButtons!
  layout: NftPageLayout
  isBurned: Boolean!
  linkAddressButton: NftLinkButton
  isHiddenByUser: Boolean!
  claimButton: Boolean @deprecated(reason: "use shownButtons")
  domain: String
  customBadge: NftCustomBadge
  colorScheme: NftColorScheme
}

enum NftCustomBadgeBackground {
  legendary
  epic
  rare
  common
  uncommon
}

type NftCustomBadge {
  background: NftCustomBadgeBackground
  text: String!
}

enum NftColorScheme {
  blue
  purple
  pink
  red
  mint
  orange
  gold
  green
}

type NftItemConnection {
  items: [NftItem!]!
  cursor: String
}

type NftCollectionConnection {
  items: [NftCollection!]!
  cursor: String
}

type DraftNftCollectionsByUserId {
  items: [DraftNftCollectionWithBlocked!]!
  cursor: String
}

type DraftNftItemsByUserId {
  items: [DraftNftItemWithBlocked!]!
  cursor: String
}

type NftItemSale {
  name: String!
  address: String!
  price: Float!
  rarityRank: Int!
  content: NftContent!
  contentSourceType: NftContentSourceType!
}

input BlockchainContent {
  name: String
  description: String
  avatarId: String
  coverId: String
  socialLinks: [SocialLinkInput!]
  royalty: Float
  royaltyAddress: String
}

input UpdateCollectionInput {
  address: String!
  isRarityEnabled: Boolean
  isBadSalesHidden: Boolean
  isAllowJettonSales: Boolean
  blockchainContent: BlockchainContent
}

type UpdateCollectionResult {
  collection: NftCollection!
  tx: TonTx
}

type ActionButtonUrl {
  url: String!
  title: String!
}

type ActionButtonEmpty {
  name: String!
}

union ActionButton = ActionButtonUrl | ActionButtonEmpty

type ResolveAddressResult {
  address: String
  isCustomContract: Boolean
}

enum SyncStatus {
  Actual
  Failed
  ContentFailed
  Success
}

type SyncNftStatus {
  nft: NftItem!
  status: SyncStatus!
  reason: String
}

type SyncCollectionStatus {
  collection: NftCollection!
  status: SyncStatus!
  reason: String
}

type AdminActionsHistoryItem {
  entityAddress: String!
  changer: String!
  createdAt: String!
  updatedState: String!
}

type AdminActionsHistoryListResponse {
  cursor: String
  items: [AdminActionsHistoryItem!]!
}

type CurrencyInfo {
  id: Currency!
  name: String!
  icon: String!
  toTonRate: Float!
  decimals: Int!
}

enum NftCollectionCategoriesTopKind {
  day
  week
  month
  all
}

enum AuctionsTopType {
  getgems
  numbers
  usernames
}

type NftItemUpdateAuctionFinish {
  type: String!
  userAddress: String!
  amount: String!
}

type NftItemUpdateAuctionCancel {
  type: String!
}

type NftItemUpdateAuctionNewBid {
  type: String!
  userAddress: String!
  amount: String!
  bid: NftAuctionBidItem!
}

union NftItemUpdatePayload = NftItemUpdateAuctionFinish | NftItemUpdateAuctionCancel | NftItemUpdateAuctionNewBid

type NftItemUpdateEvent {
  nftAddress: String!
  payload: NftItemUpdatePayload!
}

enum HistoryType {
  Mint
  Transfer
  Sold
  CancelSale
  PutUpForSale
  PutUpForAuction
  CancelAuction
  Burn
}

type HistoryTypeMint {
  type: String!
  historyType: HistoryType!
}

type HistoryTypeTransfer {
  type: String!
  historyType: HistoryType!
  oldOwner: String
  newOwner: String
  oldOwnerUser: User
  newOwnerUser: User
}

type HistoryTypeCancelSale {
  type: String!
  historyType: HistoryType!
  owner: String
  price: String
  currency: Currency!
  ownerUser: User
}

type HistoryTypeSold {
  type: String!
  historyType: HistoryType!
  oldOwner: String
  newOwner: String
  price: String
  currency: Currency!
  rejectFromGlobalTop: Boolean!
  oldOwnerUser: User
  newOwnerUser: User
}

type HistoryTypePutUpForSale {
  type: String!
  historyType: HistoryType!
  owner: String
  price: String
  currency: Currency!
  ownerUser: User
  isPriceChange: Boolean
}

type HistoryTypePutUpForAuction {
  type: String!
  historyType: HistoryType!
  owner: String
  ownerUser: User
}

type HistoryTypeCancelAuction {
  type: String!
  historyType: HistoryType!
  owner: String
  ownerUser: User
}

type HistoryTypeBurn {
  type: String!
  historyType: HistoryType!
  oldOwner: String
  newOwner: String
  oldOwnerUser: User
  newOwnerUser: User
}

union NftItemHistoryType = HistoryTypeMint | HistoryTypeTransfer | HistoryTypeCancelSale | HistoryTypeSold | HistoryTypePutUpForSale | HistoryTypePutUpForAuction | HistoryTypeCancelAuction | HistoryTypeBurn

type NftItemHistory {
  id: ID!
  address: String!
  time: Int!
  createdAt: Int!
  collectionAddress: String
  nft: NftItem
  lt: String!
  hash: String!
  typeData: NftItemHistoryType
}

type NftItemHistoryConnection {
  items: [NftItemHistory!]!
  cursor: String
}

type NftItemHistoryCounts {
  transfer: Int!
  mint: Int!
  sold: Int!
  cancelSale: Int!
  putUpForSale: Int!
  cancelAuction: Int!
  putUpForAuction: Int!
  burn: Int
  updatedAt: Int!
}

type NftCollectionOwnerStats {
  id: ID!
  ownerAddress: String!
  ownerUser: User
  collectionAddress: String!
  count: Int!
  value7d: String!
  amount7d: Int!
  updatedAt: Int!
}

type NftCollectionOwnerStatsConnection {
  items: [NftCollectionOwnerStats!]!
  cursor: String
}

type NftCollectionStatsCount {
  holders: Int!
  to1: Int!
  from2to5: Int!
  from6to24: Int!
  from25to50: Int!
  from50: Int!
  updatedAt: Int!
}

type SaleItem {
  date: Int!
  sum: String!
  sumAvg: String!
  count: Int!
  transferCount: Int
  mintCount: Int
  cancelSaleCount: Int
  putUpForSaleCount: Int
  cancelAuctionCount: Int
  putUpForAuctionCount: Int
  burnCount: Int
}

type NotcoinPriceHistoryItem {
  date: String!
  price: Float!
}

type NftCollectionSalesConnection {
  items: [SaleItem!]!
  isChartHidden: Boolean!
  notcoinPriceHistory: [NotcoinPriceHistoryItem]
}

type CollectionNftsCount {
  collection: NftCollection!
  count: Int!
}

type CollectionNftsCountConnection {
  items: [CollectionNftsCount!]!
  cursor: String
}

input RoyaltyParamsInput {
  royaltyFactor: Int!
  royaltyBase: Int!
  royaltyAddress: String!
}

input CollectionDeployParams {
  ownerAddress: String!
  collectionContent: String!
  commonContent: String!
  royaltyParams: RoyaltyParamsInput
}

input SingleNftDeployParams {
  ownerAddress: String!
  content: String!
}

type SmcDeployMessageResponse {
  contractAddress: String!
  stateInit: String
  messageBody: String
  recommendedValue: String!
}

input NftSingleInput {
  name: String!
  description: String!
  imageId: String!
  royalty: Int
  royaltyStr: String
  attributes: [MetadataAttributeInput!]
  videoId: String
}

input MetadataAttributeInput {
  trait_type: String!
  value: String!
}

input NftItemInput {
  name: String!
  description: String!
  imageId: String!
  collectionAddress: String!
  attributes: [MetadataAttributeInput!]
  videoId: String
}

type NftItemDraftDeployInfo {
  contractAddress: String!
  messageBody: String!
  collectionAddress: String!
  recommendedValue: String!
  forwardAmount: String!
}

type NftSingleDraftDeployInfo {
  contractAddress: String!
  stateInit: String!
  recommendedValue: String!
}

type CreateNftDraftResult {
  nft: DraftNftItem!
  tx: TonTx!
}

input NftCollectionInput {
  name: String!
  description: String!
  avatarId: String!
  coverId: String!
  socialLinks: [SocialLinkInput!]
  royalty: Float
  royaltyStr: String
  editableNft: Boolean
}

type DraftNftItem {
  id: ID!
  name: String!
  description: String!
  image: String!
  royalty: Int!
  royaltyStr: String
  collectionId: ID
  index: Int
  contentUri: String
  fullContentUri: String
  baseContentUri: String
}

type DraftNftCollection {
  id: ID!
  name: String!
  description: String!
  avatar: String!
  cover: String!
  socialLinks: [SocialLink!]!
  collectionContent: String
  commonContent: String
  address: String
  royaltyParams: RoyaltyParams
}

type DraftNftItemPaginated {
  items: [DraftNftItem!]!
  cursor: String
}

type CreateCollectionDraftResult {
  collection: DraftNftCollection!
  deploy: SmcDeployMessageResponse!
  tx: TonTx!
}

type DraftNftCollectionPaginated {
  items: [DraftNftCollection!]!
  cursor: String
}

type NftSaleDeployMessageResponse {
  destinationAddress: String!
  messageCell: String!
  recommendedValue: String!
  resultingSaleAddress: String!
  royaltyAmount: String!
  marketplaceFee: String!
  extra: String!
}

type MarketplaceFeeParams {
  fee: Float!
}

type NftSaleFee {
  marketplaceFee: Float!
  marketplaceFeeAddress: String!
  royaltyPercent: Float
  royaltyAddress: String
  isRoyaltyOptional: Boolean!
}

input NftAuctionParams {
  nftAddress: String!
  minBid: String!
  maxBid: String
  minStep: String
  finishAt: Int!
}

input NftAuctionNoCancelParams {
  nftAddress: String!
  minBid: String!
  maxBid: String
  minPercentStep: Int!
  finishAt: Int!
  omitRoyalty: Boolean
  currency: Currency
}

enum AuctionVersion {
  v1
  v2
}

type NftActionResult {
  tx: TonTx!
}

type NftActionMessage {
  toAddress: String! @deprecated(reason: "use tx")
  amount: String! @deprecated(reason: "use tx")
  textMessage: String! @deprecated(reason: "use tx")
  version: AuctionVersion! @deprecated(reason: "use tx")
  tx: TonTx!
}

type NftAuctionBidItem {
  id: ID!
  createdAt: Int!
  amount: String!
  currency: Currency!
  amountWithFee: String
  user: User!
}

type NftAuctionBidHistory {
  items: [NftAuctionBidItem!]!
  cursor: String
}

input NftOfferParams {
  nftAddress: String!
  price: String!
  finishAt: Int!
  omitRoyalty: Boolean
}

type NftOffer {
  currency: Currency!
  fullPrice: String!
  profitPrice: String!
  royaltyPrice: String!
  feePrice: String!
  isKnownMarketplaceFeeReceiver: Boolean!
  feeAddress: String!
  finishAt: Int!
  user: User!
  offerAddress: String!
  royaltyAddress: String!
}

type NftOfferList {
  cursor: String
  items: [NftOffer!]!
}

type AttributesCheckResponse {
  attributes: [NftAttribute!]!
}

input CartTransferNftInput {
  nftAddress: String!
  newOwnerAddress: String!
}

input CartBuyNftInput {
  nftAddress: String!
  version: String!
}

input CartPutUpForSaleNftInput {
  nftAddress: String!
  fullPrice: String!
  currency: Currency!
  omitRoyalty: Boolean
}

input CartCalculationItemInput {
  id: String!
  transferNft: CartTransferNftInput
  buyNft: CartBuyNftInput
  putUpForSaleNft: CartPutUpForSaleNftInput
}

input CartCalculationInput {
  cart: [CartCalculationItemInput!]!
}

type CartCalculationItemPayload {
  id: String!
  currency: Currency!
  networkFeeTon: String!
  value: String!
  ton: String!
  usd: String!
  rub: String!
  error: String
}

enum FilterType {
  FloorPercent
  PriceRange
}

type CollectionNotificationSetting {
  isActive: Boolean!
  filterType: FilterType!
  ltePrice: String
  gtePrice: String
  floorPercent: String
  availableTypes: [FilterType!]!
}

type CollectionNotificationSettings {
  sold: CollectionNotificationSetting!
  putUpForSale: CollectionNotificationSetting!
  putUpForAuction: CollectionNotificationSetting!
}

input CollectionNotificationSettingInput {
  isActive: Boolean!
  filterType: FilterType!
  ltePrice: String
  gtePrice: String
  floorPercent: String
}

input CollectionNotificationSettingsInput {
  sold: CollectionNotificationSettingInput
  putUpForSale: CollectionNotificationSettingInput
  putUpForAuction: CollectionNotificationSettingInput
}

type NotificationSubscribedCollection {
  address: String!
  settings: CollectionNotificationSettings!
  collection: NftCollection
}

type CollectionNotificationsList {
  cursor: String
  items: [NotificationSubscribedCollection!]
}

type NotificationSubscribedNft {
  address: String!
  settings: CollectionNotificationSettings!
  nft: NftItem
}

type NftNotificationsList {
  cursor: String
  items: [NotificationSubscribedNft!]
}

type UrlIcon {
  url: String!
}

enum DefinedIconType {
  SellOwnNft
  AuctionOverbid
  AuctionBidMyNft
  AuctionCancel
  AuctionWin
  AuctionEndsSoon
  AuctionFinish
  OfferAccept
  OfferDecline
  OfferExpired
  OfferMyNft
  EasterEggsWin
  EasterEggsLose
  EasterEggsDraw
  EasterEggsNextRound
  EasterEggsNextSale
  LaunchpadStart
  DogSexLinkCreated
  DogSexMergeSuccess
  NftPutUpForSale
  NftPutUpForAuction
  NftSold
  CollectionPutUpForSale
  CollectionPutUpForAuction
  CollectionSold
}

type DefinedIcon {
  type: DefinedIconType!
}

union LayoutIconType = DefinedIcon | UrlIcon

type SimpleLayout {
  id: ID!
  media: NftContent!
  text: String!
  createdAt: Int!
  isRead: Boolean!
  icon: LayoutIconType!
  link: String
  buttonText: String
  linkToCopy: String
  actions: [NotificationAction!]
}

union NotificationAction = NotificationActionUnsubscribe | NotificationActionEmpty

type NotificationActionUnsubscribe {
  id: ID!
}

type NotificationActionEmpty {
  _: Boolean
}

type EmptyLayout {
  _: Boolean
}

union Layout = SimpleLayout | EmptyLayout

type GroupLayout {
  id: ID!
  text: String!
  createdAt: Int!
  isRead: Boolean!
  icon: LayoutIconType!
  media: NftContent!
  notifications: [Layout!]!
}

union Notification = SimpleLayout | GroupLayout

type NotificationsList {
  cursor: String
  notifications: [Notification!]
  lastId: ID
}

enum SettingsNames {
  sellOwnNft
  auctionOverbid
  auctionBidMyNft
  auctionWin
  auctionCancel
  auctionEndsSoon
  auctionFinish
  offerAccept
  offerDecline
  offerMyNft
  offerExpired
  eeRoundActivity
  eeNextStage
  dogSexLinkCreated
  dogSexMergeSuccess
  nftPutUpForSale
  nftPutUpForAuction
  nftSold
  collectionPutUpForSale
  collectionPutUpForAuction
  collectionSold
  dnsSoonOutdated
}

type NotificationsSetting {
  key: SettingsNames!
  name: String!
  value: Boolean!
}

input SaveNotificationsSetting {
  key: SettingsNames!
  value: Boolean!
}

enum NotificationSettingBlockIcon {
  ownNftSettings
  auctionSettings
  offerSettings
  easterEggsSettings
  dogSexSettings
  nftCollectionSettings
}

type NotificationsSettingsBlock {
  name: String!
  icon: NotificationSettingBlockIcon!
  settings: [NotificationsSetting!]!
}

type ReadNotifications {
  count: Int!
}

input NTSellOwnNft {
  price: String!
  newOwner: String!
  nftAddress: String!
  sellAddress: String!
}

input NTAuctionOverbid {
  newBidAmount: String!
  userAddress: String!
  nftAddress: String!
  auctionAddress: String!
}

input NTAuctionBidMyNft {
  price: String!
  userAddress: String!
  nftAddress: String!
  auctionAddress: String!
}

input NTAuctionWin {
  price: String!
  nftAddress: String!
  auctionAddress: String!
}

input NTAuctionCancel {
  nftAddress: String!
  auctionAddress: String!
}

input NTAuctionEndsSoon {
  lastBidAmount: String!
  userAddress: String!
  endTime: Int
  nftAddress: String!
  auctionAddress: String!
}

input NTAuctionFinish {
  price: String!
  nftAddress: String!
  auctionAddress: String!
  userAddress: String!
  endTime: Int
}

input NTOfferAccept {
  price: String!
  nftAddress: String!
}

input NTOfferDecline {
  price: String!
  nftAddress: String!
}

input NTOfferMyNft {
  price: String!
  userAddress: String!
  nftAddress: String!
  offerAddress: String!
}

input NTOfferExpired {
  price: String!
  nftAddress: String!
}

input NTEasterEggs {
  nftAddress: String!
}

input NTLaunchpadStart {
  launchpadItemSlug: String!
  collectionAddress: String!
}

input NTDogSexLinkCreated {
  mergeId: String!
  nftAddress: String!
  collectionAddress: String!
}

input NTDogSexMergeSuccess {
  nftAddress: String!
  collectionAddress: String!
}

input NTNft {
  nftAddress: String!
  collectionAddress: String
  price: String!
}

input NTCollection {
  nftAddress: String!
  collectionAddress: String!
  collectionName: String!
  price: String!
  floorPrice: String
}

input NotificationTypeData {
  sellOwnNft: NTSellOwnNft
  auctionOverbid: NTAuctionOverbid
  auctionBidMyNft: NTAuctionBidMyNft
  auctionWin: NTAuctionWin
  auctionCancel: NTAuctionCancel
  auctionEndsSoon: NTAuctionEndsSoon
  auctionFinish: NTAuctionFinish
  offerAccept: NTOfferAccept
  offerDecline: NTOfferDecline
  offerMyNft: NTOfferMyNft
  offerExpired: NTOfferExpired
  easterEggsWin: NTEasterEggs
  easterEggsLose: NTEasterEggs
  easterEggsDraw: NTEasterEggs
  easterEggsNextRound: NTEasterEggs
  easterEggsNextSale: NTEasterEggs
  launchpadStart: NTLaunchpadStart
  dogSexLinkCreated: NTDogSexLinkCreated
  dogSexMergeSuccess: NTDogSexMergeSuccess
  nftPutUpForSale: NTNft
  nftPutUpForAuction: NTNft
  nftSold: NTNft
  collectionPutUpForSale: NTCollection
  collectionPutUpForAuction: NTCollection
  collectionSold: NTCollection
}

enum PearlIconType {
  everyone
  balance
  collectionHolders
  custom
}

type PearlLimitationIcon {
  icon: String
  iconType: PearlIconType!
}

type PearlLimitation {
  text: String!
  icon: PearlLimitationIcon
}

enum BadgeType {
  common
  rare
  epic
  legendary
}

type PearlCounter {
  priority: Int
  badgeType: BadgeType!
  value: String!
}

type PearlImage {
  image: String!
  badgeType: BadgeType!
}

type PearlItem {
  id: ID!
  title: String!
  description: String!
  url: String
  artistName: String!
  artistUrl: String!
  date: String!
  limitation: PearlLimitation
  additionalLimitation: PearlLimitation
  counters: [PearlCounter]!
  images: [PearlImage!]!
  isFinished: Boolean!
}

type PearlsChannelsItem {
  id: ID!
  slug: String!
  avatar: String!
  cover: String!
  address: String
  title: String!
  description: String!
  socialLinks: [SocialLink!]
}

type PearlsDropsItem {
  id: ID!
  pearlsChannelId: Int!
  pearlsChannel: PearlsChannelsItem
  title: String!
  description: String!
  slug: String!
  date: String!
  collectionAddress: String
  images: [PearlImage!]!
  nftCount: Int!
  nftImages: [String!]
}

type PearlsListResponse {
  cursor: String
  data: [PearlItem]!
}

type PearlsDropsListResponse {
  cursor: String
  items: [PearlsDropsItem!]!
}

type PearlsChannelStatsResponse {
  subscribersCount: Int!
  totalVolume: String!
  numberOfTrades: Int!
}

enum ReactionType {
  Like
}

type Reaction {
  id: ID!
  type: String!
  createdAt: Int!
  user: User!
}

type ReactionCounter {
  likes: Int!
}

type NftReactionsConnection {
  items: [Reaction!]!
  cursor: String
  nft: NftItem!
}

type ReactionsByNftAddress {
  reactions: [Reaction]!
  address: String!
}

type ReactionsByNftAddresses {
  items: [ReactionsByNftAddress]!
}

type PageInfo {
  hasNextPage: Boolean!
}

type NftItemEdge {
  node: NftItem!
  cursor: String!
}

type NftItemSearchConnection {
  edges: [NftItemEdge!]!
  info: PageInfo!
}

type NftCollectionEdge {
  node: NftCollection!
  cursor: String!
}

type NftCollectionSearchConnection {
  edges: [NftCollectionEdge!]!
  info: PageInfo!
}

type NftCollectionStats {
  floorPrice: Float
  itemsCount: Int!
  totalVolume: Float! @deprecated(reason: "use totalVolumeSold")
  totalVolumeSold: String!
  holders: Int!
}

type FilterAttributeValue {
  count: Int!
  minPrice: String
  value: String
}

type FilterAttribute {
  traitType: String!
  values: [FilterAttributeValue!]!
}

type FilterIsOnSale {
  all: Int!
  forSale: Int!
  notForSale: Int!
}

type FilterSaleType {
  none: Int!
  fixPrice: Int!
  auction: Int!
  all: Int!
}

type FilterCurrencyType {
  currencyId: Currency!
  currency: CurrencyInfo!
  count: Int!
}

type NftCollectionFilter {
  attributes: [FilterAttribute!]!
  isOnSale: FilterIsOnSale!
  saleType: FilterSaleType!
  currency: [FilterCurrencyType!]!
}

scalar Date

type SimpleTemporaryStorageValue {
  key: String!
  value: String!
  expiresAt: Int!
  publicUrl: String!
}

type MutantToadzStatus {
  presaleIsActive: Boolean!
  userCanBuy: Boolean!
  totalAmount: Int!
  purchasedAmount: Int!
  price: String!
  availableAmount: Int!
  canBuyMaxAmount: Int!
  paymentComment: String!
  paymentWallet: String!
}

enum TonTxPayloadType {
  Text
  Cell
  Empty
}

type TonTxContextItem {
  key: String!
  value: String!
}

type TonTxItem {
  to: String!
  amount: String!
  payload: String @deprecated(reason: "use payloadBoc")
  payloadType: TonTxPayloadType! @deprecated(reason: "use payloadBoc")
  stateInit: String
  payloadBoc: String
  check: String!
  context: [TonTxContextItem!]!
}

type TonTx {
  from: String
  to: String!
  deadlineTimestamp: Int!
  tonkeeperLink: String
  uuid: String!
  list: [TonTxItem!]!
}

input TonTxContextItemInput {
  key: String!
  value: String!
}

input CheckTxPayload {
  from: String
  to: String!
  amount: String!
  check: String!
  context: [TonTxContextItemInput!]!
  uuid: String!
}

enum TonTxState {
  NotReady
  Ready
  Failed
}

type TonTxStatus {
  state: TonTxState!
  extra: String
}

enum TonTxTonkeeperStatus {
  NotExist
  Created
  Took
  Broadcasted
  Rejected
}

enum TvCurrency {
  STARS
}

type TvPrice {
  value: String!
  currency: TvCurrency!
}

type TvContentWatchInApp {
  image: String!
}

type TvContentWatchExternal {
  image: String!
  url: String!
}

type TvContentInvite {
  image: String!
  requiredCount: Int!
  url: String!
}

type TvContentBuy {
  image: String!
  price: TvPrice!
  freeAt: Int
}

type TvContentNotAvailable {
  image: String!
  freeAt: Int
  earlyAccessAt: Int
}

union TvContent = TvContentWatchInApp | TvContentWatchExternal | TvContentInvite | TvContentBuy | TvContentNotAvailable

type TvEpisode {
  id: Int!
  name: String!
  number: Int!
  content: TvContent!
  isWatched: Boolean!
}

type TvSeriesUserStatus {
  earlyAccessBought: Boolean!
  currentEpisode: TvEpisode
  price: TvPrice!
}

type TvSeriesUserStatusResponse {
  status: TvSeriesUserStatus!
}

type TvEpisodesResponse {
  items: [TvEpisode!]!
}

type TvPayment {
  purchaseId: Int!
  link: String!
}

type TvPaymentResponse {
  payment: TvPayment!
}

enum TvPaymentStatus {
  paid
  progress
  failed
}

type TvCheckPaymentResponse {
  status: TvPaymentStatus!
}

type TvEpisodeVideoResponse {
  video: String!
}

enum TvEventPage {
  onboarding1
  onboarding2
  onboarding3
  project
}

input TvEventPrice {
  value: String!
  currency: TvCurrency!
}

input TvEventEpisode {
  id: Int!
  number: Int!
}

input TvEventEpisodeWithPrice {
  episode: TvEventEpisode!
  price: TvEventPrice!
}

input TapGetEarlyAccessEvent {
  episode: TvEventEpisode
  price: TvEventPrice!
}

input TvLoadVideoEvent {
  episodeId: Int!
  success: Boolean!
  mountAt: Float
  sourceLoadedAt: Float
  loadeddataAt: Float
  loadedmetadataAt: Float
  loadstartAt: Float
  canplayAt: Float
}

input TvWatchVideoEvent {
  episodeId: Int!
  mountAt: Float
  playAt: Float
  duration: Float
  p30: Float
  p60: Float
  p85: Float
}

input TvFrontEvent {
  timeMs: Float!
  launch: Boolean
  pageView: TvEventPage
  tapGetEarlyAccess: TapGetEarlyAccessEvent
  tapUnlockEpisode: TvEventEpisodeWithPrice
  tapWatchNowFor: TvEventEpisodeWithPrice
  watchEpisode: TvEventEpisode
  tapInviteFriendToWatchFree: TvEventEpisode
  inviteFriend: TvEventEpisode
  loadVideo: TvLoadVideoEvent
  watchVideo: TvWatchVideoEvent
}

input TvFrontEventUtm {
  source: String
  medium: String
  campaign: String
  term: String
  content: String
}

input TvSaveEventPayload {
  events: [TvFrontEvent!]!
  utm: TvFrontEventUtm
}

enum HistoryDefinedIconType {
  SellNft
  BuyNft
  NftPutUpForSale
  NftPutUpForAuction
  MakeOffer
  MakeAuctionBid
  CancelAuction
  CancelSale
  TransferGet
  TransferSend
  Burn
  MintNft
  MintCollection
}

type HistoryDefinedIcon {
  type: HistoryDefinedIconType!
}

union HistoryLayoutIconType = HistoryDefinedIcon | UrlIcon

type SimpleUserHistoryLayout {
  id: ID!
  title: String!
  header: String
  subHeader: String
  price: String
  currency: Currency!
  priceBadge: PriceBadge
  media: NftContent!
  createdAt: Int!
  icon: HistoryLayoutIconType!
  link: String!
}

enum PriceBadgeType {
  AuctionBidNft
  OfferNft
}

type PriceBadge {
  type: PriceBadgeType!
  price: String
}

union UserHistoryLayout = SimpleUserHistoryLayout | EmptyLayout

type UserHistoryGroupLayout {
  id: ID!
  title: String!
  icon: HistoryLayoutIconType!
  items: [UserHistoryLayout!]!
  createdAt: Int!
}

union UserHistoryItem = SimpleUserHistoryLayout | UserHistoryGroupLayout

type UserHistoryList {
  cursor: String
  items: [UserHistoryItem!]
}

type UserStats {
  tradingCount: Int!
  tradingVolume: String!
  balance: String!
  updatedAt: Int!
}

type UserCounts {
  collectedCount: Int!
  createdCount: Int!
  sbtCount: Int!
  favoritesCount: Int!
  collectionsCount: Int!
  hiddenCount: Int!
  offersCount: Int!
  updatedAt: Int!
}

enum ImageType {
  Cover @deprecated(reason: "Use UserCover or NftCollectionCover")
  Avatar @deprecated(reason: "Use UserAvatar or NftCollectionAvatar")
  Nft @deprecated(reason: "Use NftImage or NftCollectionCover or NftCollectionAvatar")
  NftImage
  NftCollectionCover
  NftCollectionAvatar
  UserCover
  UserAvatar
}

type NftVotingResponse {
  variants: [NftVotingVariant!]!
  isVoted: Boolean!
}
